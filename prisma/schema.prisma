generator client {
  provider = "prisma-client-js"
  // output   = env("PRISMA_CLIENT_OUTPUT")
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id            String   @id @default(uuid()) // ?  unique id that can be tied to blockchain as well
  email         String   @unique
  password      String
  policyConsent Boolean
  ageConsent    Boolean
  displayId     String   @unique
  firstName     String?
  lastName      String?
  description   String?
  socialLinks   String[] @default([])
  Store         Store[] // ? user can have multiple stores

  createdAt DateTime @default(now())
  updatedAt DateTime @default(now())
}

model Store {
  id           String    @id @default(uuid()) // ? unique and immutable can be used to create store pda
  title        String    @unique
  description  String?
  assets       String[]  @default([])
  taxWallet    String // ? where the taxed amount will be deposited 
  storeWallet  String // ? where the sale amount will be deposited
  storeOwner   User      @relation(fields: [userId], references: [id]) // ? 
  userId       String
  storePubkey  String // ? solana pda account
  // ? roles admin, list, delist, orders, delivery, customer support,accounts, other 
  delegates    String[]  @default([]) // ? the roles will be pdas with user id and role types so if the pda will exits on chain and these role types will be fixed
  totalRatings Int       @default(0) // ? each time a person rates its out of 5 1 star has 5 rating  so there are 5 stars in total 
  ratingCount  Int       @default(0) // ? how many time a store is rated
  Payments     Payment[] // ? a store can have multiple payment
  createdAt    DateTime  @default(now())
  updatedAt    DateTime  @default(now())
}

model Item {
  id            String    @id @default(uuid())
  description   String?
  itemCode      String    @unique
  assets        String[]  @default([])
  amount        BigInt // ? this amount will be including all the charges
  itemStatus    String // ? item state, list, delist sold or any other enum
  maxQuantity   Int       @default(1) // ? the max quantity a user can buy while creating order
  attributes    Json?
  discount      BigInt    @default(0)
  taxPercentage BigInt    @default(0)
  Payment       Payment[]
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @default(now())

  // ? self relation for other items
  parentItem    Item?  @relation("ItemToItem", fields: [id], references: [id])
  attachedItems Item[] @relation("ItemToItem") // All items attached to this item

  @@index([itemStatus])
}

model Payment {
  id              String  @id @default(uuid())
  description     String?
  type            String // ? different type of enums for payment
  transactionHash String
  store           Store   @relation(fields: [storeId], references: [id]) // ? a store can have multiple payments
  storeId         String
  amount          BigInt
  status          String // ? payemnt status

  createdAt DateTime @default(now())
  updatedAt DateTime @default(now())

  item   Item   @relation(fields: [itemId], references: [id])
  itemId String

  @@index([type])
}

// ? goal i want to get store activity, inside store you can seperate it via item activity, order activity payment history

// ? goal i want to tack store analytics like total earnings 1 day analytics

model PaymentHistoricalDataAgg {
  id        String   @id @default(uuid())
  amount    BigInt
  startDate DateTime
  endDate   DateTime

  @@index([startDate, endDate])
}

model ItemHistoricalDataAgg {
  id        String   @id @default(uuid())
  quantity  BigInt
  startDate DateTime
  endDate   DateTime

  @@index([startDate, endDate])
}
