generator client {
  provider = "prisma-client-js"
  // output   = env("PRISMA_CLIENT_OUTPUT")
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id            String   @id @default(uuid()) // ?  unique id that can be tied to blockchain as well
  email         String   @unique
  password      String
  policyConsent Boolean
  ageConsent    Boolean
  displayId     String   @unique
  firstName     String?
  lastName      String?
  description   String?
  socialLinks   String[] @default([])
  Store         Store[] // ? user can have multiple stores

  createdAt   DateTime      @default(now())
  updatedAt   DateTime      @default(now())
  StyleReview StyleReview[]
  HashVersion HashVersion[]
}

model Store {
  id                String    @id @default(uuid()) // ? unique and immutable can be used to create store pda
  title             String    @unique
  description       String?
  assets            String[]  @default([])
  taxWallet         String // ? where the taxed amount will be deposited 
  storeWallet       String // ? where the sale amount will be deposited
  storeOwner        User      @relation(fields: [userId], references: [id]) // ? 
  userId            String
  storePubkey       String // ? solana pda account
  // ? roles admin, list, delist, orders, delivery, customer support,accounts, other 
  delegates         String[]  @default([]) // ? the roles will be pdas with user id and role types so if the pda will exits on chain and these role types will be fixed
  totalRatings      Int       @default(0) // ? each time a person rates its out of 5 1 star has 5 rating  so there are 5 stars in total 
  ratingCount       Int       @default(0) // ? how many time a store is rated
  Payments          Payment[] // ? a store can have multiple payment
  createdAt         DateTime  @default(now())
  updatedAt         DateTime  @default(now())
  totalTradedVolume BigInt    @default(0)
}

model Style {
  id                String   @id @default(uuid())
  description       String?
  styleAvailability String // ? mto, instock or both
  styleCode         String   @unique
  assets            String[] @default([])
  amount            BigInt // ? this amount will be including all the charges
  styleStatus       String // ? item state, list, delist,achieve update or any other enum
  maxOrderCount     Int      @default(1) // ? the max quantity a user can buy while creating order

  totalRatings Int @default(0) // ? each time a person rates its out of 5 1 star has 5 rating  so there are 5 stars in total 
  ratingCount  Int @default(0) // ? how many time a store is rated

  attributes    Json?
  discount      BigInt    @default(0)
  taxPercentage BigInt    @default(0)
  Payment       Payment[]
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @default(now())

  // ? self relation for other items
  parentItemId  String?
  parentItem    Style?  @relation("ItemToItem", fields: [parentItemId], references: [id])
  attachedItems Style[] @relation("ItemToItem") // All items attached to this item

  activities  StyleLogs[]
  Inventory   Inventory? // ? 1 to 1 relation ship
  StyleReview StyleReview[]

  @@index([styleStatus])
}

// ? use to track style activity list delist update archieve
model StyleLogs {
  id   String @id @default(uuid())
  type String // ? activity type list delist update archieve

  startDate DateTime
  endDate   DateTime

  style   Style?  @relation(fields: [styleId], references: [id])
  styleId String?

  @@index([type])
  @@index([startDate, endDate])
}

// ? manage style stocks
model Inventory {
  id            String @id @default(uuid())
  freeUnits     Int    @default(0)
  reservedUnits Int    @default(0)

  style   Style  @relation(fields: [styleId], references: [id])
  styleId String @unique
}

// ? review made by customer on style will be stored off chain
model StyleReview {
  id        String   @id @default(uuid())
  title     String
  content   String
  createdAt DateTime @default(now())

  totalRatings Int @default(0) // ? each time a person rates its out of 5 1 star has 5 rating  so there are 5 stars in total 

  // Relations
  style   Style  @relation(fields: [styleId], references: [id])
  styleId String

  user   User   @relation(fields: [userId], references: [id])
  userId String

  contentSignedHash String // ? a user must be have linked wallet and must sign it user id and content

  // Self-relation for replies
  parentId     String?
  parentReview StyleReview?  @relation("ReviewReplies", fields: [parentId], references: [id])
  replies      StyleReview[] @relation("ReviewReplies")

  @@index([styleId])
  @@index([parentId])
}

model Payment {
  id              String  @id @default(uuid())
  description     String?
  type            String // ? different type of enums for payment
  transactionHash String
  store           Store   @relation(fields: [storeId], references: [id]) // ? a store can have multiple payments
  storeId         String
  amount          BigInt
  status          String // ? payemnt status

  createdAt DateTime @default(now())
  updatedAt DateTime @default(now())

  item   Style  @relation(fields: [itemId], references: [id])
  itemId String

  @@index([type])
}

// ? goal i want to get store activity, inside store you can seperate it via item activity, order activity payment history

// ? goal i want to tack store analytics like total earnings 1 day analytics
// ? will cache data for 1 day

model PaymentHistoricalDataAgg {
  id        String   @id @default(uuid())
  amount    BigInt
  startDate DateTime
  endDate   DateTime

  @@index([startDate, endDate])
}

model ItemHistoricalDataAgg {
  id        String   @id @default(uuid())
  quantity  BigInt
  startDate DateTime
  endDate   DateTime

  @@index([startDate, endDate])
}

// ? to store hash and its data 
model HashVersion {
  id        String   @id @default(uuid())
  type      String // ? store, style what type data the json value hold
  data      Json
  hash      String
  version   Int
  createdAt DateTime
  updatedBy User     @relation(fields: [userId], references: [id])
  userId    String

  @@index([hash])
}

// ? we will use compressed data, the data will be compressed like it will have json and will stringify that json sort it and create a sha256 hash then will store that sha256 hashed string using a pda and pda will have a timestamp and hash itself, we see if we can generate pda from buffer of hashed data
// ? will store hash versioning in blockchain iteself like the hash version updated by
